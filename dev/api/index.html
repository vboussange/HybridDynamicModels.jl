<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · HybridDynamicModels.jl</title><meta name="title" content="API · HybridDynamicModels.jl"/><meta property="og:title" content="API · HybridDynamicModels.jl"/><meta property="twitter:title" content="API · HybridDynamicModels.jl"/><meta name="description" content="Documentation for HybridDynamicModels.jl."/><meta property="og:description" content="Documentation for HybridDynamicModels.jl."/><meta property="twitter:description" content="Documentation for HybridDynamicModels.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="HybridDynamicModels.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">HybridDynamicModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../examples/data_loading/">Data Loading with <code>SegmentedTimeSeries</code></a></li><li><a class="tocitem" href="../examples/sgd_example/">Training with <code>SGDBackend</code></a></li><li><a class="tocitem" href="../examples/mcsampling_example/">Bayesian inference with <code>MCSamplingBackend</code></a></li><li><a class="tocitem" href="../examples/customtraining_example/">Overloading the <code>train</code> function</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Dataloaders"><span>Dataloaders</span></a></li><li><a class="tocitem" href="#Parameter-Layers"><span>Parameter Layers</span></a></li><li><a class="tocitem" href="#Models"><span>Models</span></a></li><li><a class="tocitem" href="#Initial-Conditions"><span>Initial Conditions</span></a></li><li><a class="tocitem" href="#Training-API"><span>Training API</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/vboussange/HybridDynamicModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/vboussange/HybridDynamicModels.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Dataloaders"><a class="docs-heading-anchor" href="#Dataloaders">Dataloaders</a><a id="Dataloaders-1"></a><a class="docs-heading-anchor-permalink" href="#Dataloaders" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridDynamicModels.SegmentedTimeSeries" href="#HybridDynamicModels.SegmentedTimeSeries"><code>HybridDynamicModels.SegmentedTimeSeries</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SegmentedTimeSeries(data; segment_length=2, shift=nothing, batchsize=1, shuffle=false, partial_segment=false, partial_batch=false, rng=GLOBAL_RNG)</code></pre><p>An object that iterates over mini-batches of segments of <code>data</code>, each segment containing <code>segment_length</code> data points, each mini-batch containing <code>batchsize</code> segments. The last dimension in each tensor is the time dimension.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: Input data (array, tuple, or named tuple).</li><li><code>segment_length</code>: Number of time points in each segment.</li><li><code>shift</code>: Step size between consecutive segments (default: <code>segment_length</code>).</li><li><code>batchsize</code>: Number of segments per batch.</li><li><code>shuffle</code>: Whether to shuffle segment order.</li><li><code>partial_segment</code>: Allow shorter final segments.</li><li><code>partial_batch</code>: Allow smaller final batches.</li><li><code>rng</code>: Random number generator for shuffling.</li></ul><p><strong>Inputs</strong></p><ul><li><code>data</code>: The time series data to segment.</li></ul><p><strong>Outputs</strong></p><ul><li>Iterator yielding batches of data segments.</li></ul><p><strong>Behavior</strong></p><p>Creates overlapping or non-overlapping segments from time series data for training dynamical models. Segments can be shuffled and batched for efficient training.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Xtrain = rand(10, 100)
julia&gt; sdl = SegmentedTimeSeries(Xtrain; segment_length=2, batchsize=1)
julia&gt; for batch in sdl
           println(&quot;Batch: &quot;, summary(batch))
       end</code></pre><p>!!!warning     Undefined behavior when data dimensions are incompatible</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vboussange/HybridDynamicModels.jl/blob/e9e680a3e24f31977a06b803d8bdf93eabaf3d3d/src/data.jl#L1-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridDynamicModels.tokenize" href="#HybridDynamicModels.tokenize"><code>HybridDynamicModels.tokenize</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tokenize(sdl::SegmentedTimeSeries)</code></pre><p>Convert a SegmentedTimeSeries to use token-based indexing.</p><p><strong>Arguments</strong></p><ul><li><code>sdl</code>: The SegmentedTimeSeries to tokenize.</li></ul><p><strong>Inputs</strong></p><ul><li><code>sdl</code>: SegmentedTimeSeries object.</li></ul><p><strong>Outputs</strong></p><ul><li>Tokenized SegmentedTimeSeries with integer-based segment access.</li></ul><p><strong>Behavior</strong></p><p>Transforms segment indices into a token-based system for easier access to individual segments.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sdl = SegmentedTimeSeries(rand(10, 100); segment_length=2)
julia&gt; tokenized_sdl = tokenize(sdl)
julia&gt; tokens(tokenized_sdl) # Returns available tokens</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vboussange/HybridDynamicModels.jl/blob/e9e680a3e24f31977a06b803d8bdf93eabaf3d3d/src/data.jl#L138-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridDynamicModels.tokens" href="#HybridDynamicModels.tokens"><code>HybridDynamicModels.tokens</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tokens(sdl::SegmentedTimeSeries)</code></pre><p>Get the available tokens for a tokenized SegmentedTimeSeries.</p><p><strong>Arguments</strong></p><ul><li><code>sdl</code>: A tokenized SegmentedTimeSeries.</li></ul><p><strong>Inputs</strong></p><ul><li><code>sdl</code>: Tokenized SegmentedTimeSeries object.</li></ul><p><strong>Outputs</strong></p><ul><li>Range of available tokens (1 to number of segments).</li></ul><p><strong>Behavior</strong></p><p>Returns the range of tokens that can be used to access individual segments in a tokenized SegmentedTimeSeries.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sdl = SegmentedTimeSeries(rand(10, 100); segment_length=2)
julia&gt; tokenized_sdl = tokenize(sdl)
julia&gt; collect(tokens(tokenized_sdl)) # [1, 2, 3, ...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vboussange/HybridDynamicModels.jl/blob/e9e680a3e24f31977a06b803d8bdf93eabaf3d3d/src/data.jl#L177-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridDynamicModels.create_train_val_loaders" href="#HybridDynamicModels.create_train_val_loaders"><code>HybridDynamicModels.create_train_val_loaders</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_train_val_loaders(data; segment_length, valid_length, kwargs...)</code></pre><p>Create separate training and validation SegmentedTimeSeries loaders from a dataset with the same number of batches.</p><p>This function splits the data into non-overlapping training and validation segments. The training data uses segments with gaps equal to <code>valid_length</code> to leave space for validation segments. The validation data starts after the first training segment and uses segments of length <code>valid_length</code>. Both loaders are guaranteed to have the same number of batches, with tokens referring to the same ordering.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: Input data (can be an array, tuple, or named tuple)</li><li><code>segment_length</code>: Size of training segments</li><li><code>valid_length</code>: Size of validation segments</li><li><code>kwargs...</code>: Additional arguments passed to SegmentedTimeSeries constructors</li></ul><p><strong>Returns</strong></p><ul><li><code>dataloader_train</code>: SegmentedTimeSeries for training data</li><li><code>dataloader_valid</code>: SegmentedTimeSeries for validation data</li></ul><p><strong>Examples</strong></p><p><strong>With array data</strong></p><pre><code class="language-julia hljs">data = rand(10, 100)  # 10 features, 100 time steps
train_loader, val_loader = create_train_val_loaders(data; 
    segment_length=20, valid_length=5, batchsize=4)
# Both loaders will have the same number of batches
@assert length(train_loader) == length(val_loader)</code></pre><p><strong>With tuple data (data, time steps)</strong></p><pre><code class="language-julia hljs">data = rand(10, 100)
tsteps = 1:100
train_loader, val_loader = create_train_val_loaders((data, tsteps); 
    segment_length=20, valid_length=5, batchsize=4)</code></pre><p><strong>With named tuple data</strong></p><pre><code class="language-julia hljs">dataset = (observations = rand(10, 100), times = 1:100, metadata = rand(5, 100))
train_loader, val_loader = create_train_val_loaders(dataset; 
    segment_length=20, valid_length=5)</code></pre><p><strong>Notes</strong></p><ul><li>Training segments are spaced <code>segment_length + valid_length</code> apart to avoid overlap with validation</li><li>Validation segments start at position <code>segment_length + 1</code> to avoid overlap with first training segment</li><li>Both loaders have <code>partial_segment = false</code> and <code>partial_batch = false</code> to ensure consistent sizes</li><li>Both loaders are guaranteed to have the same number of batches for synchronized training/validation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vboussange/HybridDynamicModels.jl/blob/e9e680a3e24f31977a06b803d8bdf93eabaf3d3d/src/data.jl#L214-L266">source</a></section></article><h2 id="Parameter-Layers"><a class="docs-heading-anchor" href="#Parameter-Layers">Parameter Layers</a><a id="Parameter-Layers-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter-Layers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridDynamicModels.ParameterLayer" href="#HybridDynamicModels.ParameterLayer"><code>HybridDynamicModels.ParameterLayer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ParameterLayer(;constraint::AbstractConstraint = NoConstraint(), 
                init_value = (;), 
                init_state_value = (;))</code></pre><p>A layer representing parameters, optionally with constraints.</p><p><strong>Arguments</strong></p><ul><li><code>constraint</code>: Constraint to transform parameters.</li><li><code>init_value</code>: Initial parameter values (NamedTuple or AbstractArray).</li><li><code>init_state_value</code>: Internal state (NamedTuple).</li></ul><p><strong>Inputs</strong></p><ul><li><code>ps</code>: Parameters of the layer.</li><li><code>st</code>: States of the layer.</li></ul><p><strong>Outputs</strong></p><ul><li>Constrained parameter values merged with states.</li></ul><p><strong>Behavior</strong></p><p>Applies constraints to parameters during forward pass. Parameters are transformed from unconstrained to constrained space.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; param = ParameterLayer(; constraint = NoConstraint(),
                            init_value = (;a = ones(2)), 
                            init_state_value = (;b = (0.0, 1.0)))
julia&gt; ps, st = Lux.setup(Random.default_rng(), param)
julia&gt; x, _ = param(ps, st)
julia&gt; x == (a = [1.0, 1.0], b = (0.0, 1.0))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vboussange/HybridDynamicModels.jl/blob/e9e680a3e24f31977a06b803d8bdf93eabaf3d3d/src/layers/utilities/parameter.jl#L2-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridDynamicModels.NoConstraint" href="#HybridDynamicModels.NoConstraint"><code>HybridDynamicModels.NoConstraint</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NoConstraint()</code></pre><p>Applies no transformation to parameters.</p><p><strong>Arguments</strong></p><ul><li>None.</li></ul><p><strong>Inputs</strong></p><ul><li><code>x</code>: Parameter values.</li><li><code>st</code>: States.</li></ul><p><strong>Outputs</strong></p><ul><li>Unmodified parameter values and states.</li></ul><p><strong>Behavior</strong></p><p>Identity transformation - parameters remain unconstrained.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; constraint = NoConstraint()
julia&gt; x, st = constraint([1.0, 2.0], (;))
([1.0, 2.0], (;))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vboussange/HybridDynamicModels.jl/blob/e9e680a3e24f31977a06b803d8bdf93eabaf3d3d/src/constraints.jl#L10-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridDynamicModels.BoxConstraint" href="#HybridDynamicModels.BoxConstraint"><code>HybridDynamicModels.BoxConstraint</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BoxConstraint(lb::AbstractArray, ub::AbstractArray)</code></pre><p>Constrains parameters to lie within specified bounds using sigmoid transformation.</p><p><strong>Arguments</strong></p><ul><li><code>lb</code>: Lower bounds array.</li><li><code>ub</code>: Upper bounds array.</li></ul><p><strong>Inputs</strong></p><ul><li><code>y</code>: Unconstrained parameter values.</li><li><code>st</code>: States containing bounds.</li></ul><p><strong>Outputs</strong></p><ul><li>Constrained parameter values within bounds.</li></ul><p><strong>Behavior</strong></p><p>Transforms unconstrained parameters to constrained space using sigmoid function.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; constraint = BoxConstraint([0.0], [1.0])
julia&gt; x, st = constraint([0.0], (;lb=[0.0], ub=[1.0]))
([0.5], (;lb=[0.0], ub=[1.0]))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vboussange/HybridDynamicModels.jl/blob/e9e680a3e24f31977a06b803d8bdf93eabaf3d3d/src/constraints.jl#L41-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridDynamicModels.NamedTupleConstraint" href="#HybridDynamicModels.NamedTupleConstraint"><code>HybridDynamicModels.NamedTupleConstraint</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NamedTupleConstraint(constraints::NamedTuple)</code></pre><p>Applies different constraints to different fields of a NamedTuple.</p><p><strong>Arguments</strong></p><ul><li><code>constraints</code>: NamedTuple of constraint objects.</li></ul><p><strong>Inputs</strong></p><ul><li><code>x</code>: NamedTuple of parameter values.</li><li><code>st</code>: NamedTuple of states.</li></ul><p><strong>Outputs</strong></p><ul><li>Constrained parameter values.</li></ul><p><strong>Behavior</strong></p><p>Applies field-specific constraints to NamedTuple parameters.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; constraints = (a = BoxConstraint([0.0], [1.0]), b = NoConstraint())
julia&gt; constraint = NamedTupleConstraint(constraints)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vboussange/HybridDynamicModels.jl/blob/e9e680a3e24f31977a06b803d8bdf93eabaf3d3d/src/constraints.jl#L97-L121">source</a></section></article><h2 id="Models"><a class="docs-heading-anchor" href="#Models">Models</a><a id="Models-1"></a><a class="docs-heading-anchor-permalink" href="#Models" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridDynamicModels.ODEModel" href="#HybridDynamicModels.ODEModel"><code>HybridDynamicModels.ODEModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ODEModel(layers::NamedTuple, dudt::Function; kwargs...)</code></pre><p>Wraps an ODE model for simulation using Lux layers.</p><p><strong>Arguments</strong></p><ul><li><code>layers</code>: NamedTuple of Lux layers representing the layers of the model.</li><li><code>dudt</code>: Function that computes the derivative of the state, with signature <code>dudt(layers, u, ps, t)</code>.</li><li><code>kwargs</code>: Additional keyword arguments passed to the solver (e.g., <code>tspan</code>, <code>saveat</code>, <code>alg</code>).</li></ul><p><strong>Inputs</strong></p><ul><li>(<code>x</code>, <code>ps</code>, <code>st</code>)<ul><li><code>x</code>: a <code>NamedTuple</code> or <code>AbstractVector{NamedTuple}</code> (batch mode).</li><li><code>ps</code>: Parameters of the model.</li><li><code>st</code>: States of the model.</li></ul></li><li>A tuple of (<code>x</code>, <code>ps</code>, <code>st</code>): batch mode.</li><li>(<code>ps</code>, <code>st</code>): If <code>x</code> not provided, defaults to <code>kwargs</code>.</li></ul><p><strong>Outputs</strong></p><ul><li>(<code>sol</code>, <code>st</code>)<ul><li><code>sol</code>: Solution of the ODE problem, with second dimension corresponding to time and batches stacked along the third dimension, if applicable.</li><li><code>st</code>: Updated states of the model.</li></ul></li></ul><p><strong>Behavior</strong></p><p><code>layers</code> are wrapped in <code>StatefulLuxLayer</code>s to maintain their states. The derivative function <code>dudt</code> should be defined as <code>dudt(layers, u, ps, t)</code> where <code>u</code> is the current state and <code>t</code> is the current time. The function returns the derivative of the state.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; layers = (; layer1 = Lux.Dense(10, 10, relu))
julia&gt; dudt(layers, u, ps, t) = layers.layer1(u, ps.layer1)[1]
julia&gt; ode_model = ODEModel(layers, dudt, tspan = (0f0, 1f0), saveat = range(0f0, stop=1f0, length=100), alg = Tsit5())
julia&gt; ps, st = Lux.setup(Random.default_rng(), ode_model)
julia&gt; ode_model((; u0 = ones(Float32, 10)), ps, st)</code></pre><p>!!!warning     Undefined behavior when <code>ps</code> is not a NamedTuple</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vboussange/HybridDynamicModels.jl/blob/e9e680a3e24f31977a06b803d8bdf93eabaf3d3d/src/layers/models/odemodel.jl#L1-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridDynamicModels.AnalyticModel" href="#HybridDynamicModels.AnalyticModel"><code>HybridDynamicModels.AnalyticModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AnalyticModel(layers::NamedTuple, fun::Function; kwargs...)</code></pre><p>Wraps an analytic model for direct evaluation using Lux layers.</p><p><strong>Arguments</strong></p><ul><li><code>layers</code>: NamedTuple of Lux layers representing the layers of the model.</li><li><code>fun</code>: Function that computes the analytic solution, with signature <code>fun(layers, u0, t0, ps, t)</code>.</li><li><code>kwargs</code>: Additional keyword arguments (e.g., default values for <code>u0</code>, <code>tspan</code>, <code>saveat</code>).</li></ul><p><strong>Inputs</strong></p><ul><li>(<code>x</code>, <code>ps</code>, <code>st</code>)<ul><li><code>x</code>: a <code>NamedTuple</code> or <code>AbstractVector{NamedTuple}</code> (batch mode).</li><li><code>ps</code>: Parameters of the model.</li><li><code>st</code>: States of the model.</li></ul></li><li>A tuple of (<code>x</code>, <code>ps</code>, <code>st</code>): batch mode.</li><li>(<code>ps</code>, <code>st</code>): If <code>x</code> not provided, defaults to <code>kwargs</code>.</li></ul><p><strong>Outputs</strong></p><ul><li>(<code>sol</code>, <code>st</code>)<ul><li><code>sol</code>: Solution array evaluated at specified time points, with second dimension corresponding to time and batches stacked along the third dimension, if applicable.</li><li><code>st</code>: Updated states of the model.</li></ul></li></ul><p><strong>Behavior</strong></p><p><code>layers</code> are wrapped in <code>StatefulLuxLayer</code> to maintain their states. The analytic function <code>fun</code> should be defined as <code>fun(layers, u0, t0, ps, t)</code> where <code>t</code> can be a vector of time points and <code>t0</code> is extracted from <code>tspan</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; layers = (; params = ParameterLayer(init_value = (a = 1.0, b = 0.5)))
julia&gt; analytic_solution(layers, u0, t0, ps, t) = u0 .* exp.(layers.params(ps.params)[1].a .* (t .- t0))
julia&gt; model = AnalyticModel(layers, analytic_solution; u0 = [1.0], tspan = (0.0, 1.0), saveat = 0:0.1:1.0)
julia&gt; ps, st = Lux.setup(Random.default_rng(), model)
julia&gt; model((; u0 = [1.0]), ps, st)</code></pre><p>!!!warning     Undefined behavior when <code>ps</code> is not a NamedTuple</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vboussange/HybridDynamicModels.jl/blob/e9e680a3e24f31977a06b803d8bdf93eabaf3d3d/src/layers/models/analyticmodel.jl#L2-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridDynamicModels.ARModel" href="#HybridDynamicModels.ARModel"><code>HybridDynamicModels.ARModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ARModel(layers::NamedTuple, fun::Function; kwargs...)</code></pre><p>Wraps an autoregressive (AR) model.</p><p><strong>Arguments</strong></p><ul><li><code>layers</code>: NamedTuple of Lux layers representing the layers associated with the model.</li><li><code>fun</code>: Function that computes the next time step, with signature <code>fun(layers, u, ps, t)</code>.</li><li><code>kwargs</code>: Additional keyword arguments (e.g., default values for <code>u0</code>, <code>tspan</code>, <code>saveat</code>, <code>dt</code>).</li></ul><p><strong>Inputs</strong></p><ul><li>(<code>x</code>, <code>ps</code>, <code>st</code>)<ul><li><code>x</code>: a <code>NamedTuple</code> or <code>AbstractVector{NamedTuple}</code> (batch mode).</li><li><code>ps</code>: Parameters of the model.</li><li><code>st</code>: States of the model.</li></ul></li><li>A tuple of (<code>x</code>, <code>ps</code>, <code>st</code>): batch mode.</li><li>(<code>ps</code>, <code>st</code>): If <code>x</code> not provided, defaults to <code>kwargs</code>.</li></ul><p><strong>Outputs</strong></p><ul><li>(<code>sol</code>, <code>st</code>)<ul><li><code>sol</code>: Solution array with iterative predictions, with second dimension corresponding to time and batches stacked along the third dimension, if applicable.</li><li><code>st</code>: Updated states of the model.</li></ul></li></ul><p><strong>Behavior</strong></p><p><code>layers</code> are wrapped in <code>StatefulLuxLayer</code> to maintain their states. The AR function <code>fun</code> should be defined as <code>fun(layers, u, ps, t)</code> where:</p><ul><li><code>u</code> is the current state</li><li><code>t</code> is the current time</li><li>The function returns the next state</li></ul><p>The model iteratively applies the function to generate a time series from initial conditions.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using HybridDynamicModels, Lux, Random

julia&gt; layers = (; 
           predictor = Dense(2, 2), 
           params = ParameterLayer(init_value = (; decay = [95f-2],))
       );

julia&gt; ar_step(layers, u, ps, t) = layers.predictor(u, ps.predictor) .* layers.params(ps.params).decay;

julia&gt; model = ARModel(layers, ar_step; dt = 1f-1, u0 = [1f0, 5f-1], tspan = (0f0, 1f0), saveat = 0:1f-1:1f0);

julia&gt; ps, st = Lux.setup(Random.default_rng(), model);

julia&gt; x = (; u0 = [1f0, 5f-1]);

julia&gt; y, st = model(x, ps, st);

julia&gt; size(y) # 2 state variables, 11 time points
(2, 11) </code></pre><p>!!!warning     Undefined behavior when <code>x</code> is not a NamedTuple</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vboussange/HybridDynamicModels.jl/blob/e9e680a3e24f31977a06b803d8bdf93eabaf3d3d/src/layers/models/armodel.jl#L1-L58">source</a></section></article><h2 id="Initial-Conditions"><a class="docs-heading-anchor" href="#Initial-Conditions">Initial Conditions</a><a id="Initial-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-Conditions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridDynamicModels.ICLayer" href="#HybridDynamicModels.ICLayer"><code>HybridDynamicModels.ICLayer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ICLayer(ics::AbstractLuxLayer)
ICLayer(ics::&lt;:ParameterLayer)
ICLayer(ics::Vector{&lt;:ParameterLayer})</code></pre><p>Initial condition layer.</p><p><strong>Arguments</strong></p><ul><li><code>ics</code>: Lux layer, ParameterLayer, or vector of ParameterLayer.</li></ul><p><strong>Inputs</strong></p><ul><li>(<code>x</code>, <code>ps</code>, <code>st</code>) with <code>x</code> a NamedTuple or AbstractVector{NamedTuple} (batch mode).</li><li>(<code>ps</code>, <code>st</code>) when <code>ics</code> is a ParameterLayer.</li></ul><p><strong>Outputs</strong></p><ul><li>Initial conditions merged with other fields.</li><li>Updated states.</li></ul><p><strong>Behavior</strong></p><p>Processes initial conditions through wrapped layers and merges with input data.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ic_layer = ICLayer(ParameterLayer(init_value = (;u0 = [1.0])))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vboussange/HybridDynamicModels.jl/blob/e9e680a3e24f31977a06b803d8bdf93eabaf3d3d/src/layers/utilities/initialconditions.jl#L1-L27">source</a></section></article><h2 id="Training-API"><a class="docs-heading-anchor" href="#Training-API">Training API</a><a id="Training-API-1"></a><a class="docs-heading-anchor-permalink" href="#Training-API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridDynamicModels.train" href="#HybridDynamicModels.train"><code>HybridDynamicModels.train</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">train(backend::AbstractOptimBackend, model, dataloader::SegmentedTimeSeries, infer_ics::InferICs, rng=Random.default_rng(); pstype=Lux.f64)</code></pre><p>Train a dynamical model using segmented time series data.</p><p><strong>Arguments</strong></p><ul><li><code>backend</code>: Training configuration and optimization settings.</li><li><code>model</code>: Lux model to train.</li><li><code>dataloader</code>: Time series data split into segments.</li><li><code>infer_ics</code>: Initial condition inference configuration.</li><li><code>rng</code>: Random number generator.</li><li><code>pstype</code>: Precision type for parameters.</li></ul><p><strong>Inputs</strong></p><ul><li><code>backend</code>: Training backend (SGDBackend, MCSamplingBackend, etc.).</li><li><code>model</code>: Model to train.</li><li><code>dataloader</code>: SegmentedTimeSeries data.</li><li><code>infer_ics</code>: InferICs configuration.</li></ul><p><strong>Outputs</strong></p><ul><li>NamedTuple with training results (varies by backend).</li></ul><p><strong>Behavior</strong></p><p>Trains model using specified backend on segmented time series data.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; backend = SGDBackend(Adam(1e-3), 1000, AutoZygote(), MSELoss())
julia&gt; dataloader = SegmentedTimeSeries(data, segment_length=20)
julia&gt; infer_ics = InferICs(true)
julia&gt; result = train(backend, model, dataloader, infer_ics)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vboussange/HybridDynamicModels.jl/blob/e9e680a3e24f31977a06b803d8bdf93eabaf3d3d/src/train.jl#L126-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridDynamicModels.InferICs" href="#HybridDynamicModels.InferICs"><code>HybridDynamicModels.InferICs</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InferICs(infer::Bool, u0_constraint=NoConstraint())</code></pre><p>Configuration for initial condition inference in training.</p><p><strong>Arguments</strong></p><ul><li><code>infer</code>: Whether to treat initial conditions as learnable parameters.</li><li><code>u0_constraint</code>: Constraint for initial condition optimization.</li></ul><p><strong>Inputs</strong></p><ul><li><code>infer</code>: Boolean flag for inference.</li><li><code>u0_constraint</code>: Constraint object.</li></ul><p><strong>Outputs</strong></p><ul><li>InferICs configuration object.</li></ul><p><strong>Behavior</strong></p><p>Controls whether initial conditions are learned or fixed during training.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; infer_ics = InferICs(true, NoConstraint())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vboussange/HybridDynamicModels.jl/blob/e9e680a3e24f31977a06b803d8bdf93eabaf3d3d/src/train.jl#L92-L116">source</a></section></article><h3 id="Lux.jl-training-backend"><a class="docs-heading-anchor" href="#Lux.jl-training-backend"><code>Lux.jl</code> training backend</a><a id="Lux.jl-training-backend-1"></a><a class="docs-heading-anchor-permalink" href="#Lux.jl-training-backend" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridDynamicModels.SGDBackend" href="#HybridDynamicModels.SGDBackend"><code>HybridDynamicModels.SGDBackend</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SGDBackend(opt, n_epochs, adtype, loss_fn, callback)</code></pre><p>Training backend using Lux.jl for mode estimation.</p><p>!!! warning <code>Conditional loading</code>   You need to load <code>Optimisers</code>, <code>ComponentArrays</code> and <code>Lux</code> before loading <code>HybridDynamicModels</code> to use <a href="#HybridDynamicModels.SGDBackend">SGDBackend</a>.</p><p><strong>Arguments</strong></p><ul><li><code>opt</code>: Optimizers.jl rule for parameter updates.</li><li><code>n_epochs</code>: Number of training epochs.</li><li><code>adtype</code>: Automatic differentiation backend.</li><li><code>loss_fn</code>: Loss function for training.</li><li><code>callback</code>: User-defined callback function.</li></ul><p><strong>Inputs</strong></p><ul><li><code>opt</code>: Optimization rule (e.g., Adam(1e-3)).</li><li><code>n_epochs</code>: Total training epochs.</li><li><code>adtype</code>: AD backend (e.g., AutoZygote()).</li><li><code>loss_fn</code>: Loss function.</li><li><code>callback</code>: Optional callback.</li></ul><p><strong>Outputs</strong></p><ul><li>NamedTuple with trained parameters and states.</li></ul><p><strong>Behavior</strong></p><p>Uses stochastic gradient descent for maximum likelihood estimation.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; backend = SGDBackend(Adam(1e-3), 1000, AutoZygote(), MSELoss())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vboussange/HybridDynamicModels.jl/blob/e9e680a3e24f31977a06b803d8bdf93eabaf3d3d/src/train.jl#L4-L37">source</a></section></article><h3 id="Turing.jl-backend"><a class="docs-heading-anchor" href="#Turing.jl-backend"><code>Turing.jl</code> backend</a><a id="Turing.jl-backend-1"></a><a class="docs-heading-anchor-permalink" href="#Turing.jl-backend" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridDynamicModels.BayesianLayer" href="#HybridDynamicModels.BayesianLayer"><code>HybridDynamicModels.BayesianLayer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BayesianLayer(layer, priors)</code></pre><p>Wrapper layer that adds Bayesian priors to Lux layers for probabilistic modeling.</p><p><strong>Arguments</strong></p><ul><li><code>layer</code>: Lux layer to make Bayesian.</li><li><code>priors</code>: Prior distributions for parameters.</li></ul><p><strong>Inputs</strong></p><ul><li><code>layer</code>: Any Lux layer.</li><li><code>priors</code>: Distribution or NamedTuple of distributions.</li></ul><p><strong>Outputs</strong></p><ul><li>Layer with Bayesian priors for MCMC inference.</li></ul><p><strong>Behavior</strong></p><p>Enables probabilistic modeling by attaching priors to layer parameters.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; dense_layer = Dense(10, 5)
julia&gt; bayesian_dense = BayesianLayer(dense_layer, Normal(0, 1))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vboussange/HybridDynamicModels.jl/blob/e9e680a3e24f31977a06b803d8bdf93eabaf3d3d/src/layers/utilities/bayesian_layer.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridDynamicModels.getpriors" href="#HybridDynamicModels.getpriors"><code>HybridDynamicModels.getpriors</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getpriors(layer)</code></pre><p>Extract prior distributions from Bayesian layers.</p><p><strong>Arguments</strong></p><ul><li><code>layer</code>: Layer or model containing BayesianLayer components.</li></ul><p><strong>Inputs</strong></p><ul><li><code>layer</code>: Bayesian or composite layer.</li></ul><p><strong>Outputs</strong></p><ul><li>NamedTuple of prior distributions.</li></ul><p><strong>Behavior</strong></p><p>Recursively extracts priors from Bayesian layers in model hierarchy.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; priors = getpriors(bayesian_model)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vboussange/HybridDynamicModels.jl/blob/e9e680a3e24f31977a06b803d8bdf93eabaf3d3d/src/layers/utilities/bayesian_layer.jl#L30-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridDynamicModels.create_turing_model" href="#HybridDynamicModels.create_turing_model"><code>HybridDynamicModels.create_turing_model</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_turing_model(ps_priors, data_distrib, st_model)</code></pre><p>Create a Turing model for Bayesian inference from a <code>BayesianLayer</code> model.</p><p><strong>Arguments</strong></p><ul><li><code>ps_priors</code>: A nested structure (typically a NamedTuple) containing prior distributions for model parameters. Each leaf should be a <code>Distributions.Distribution</code>.</li><li><code>data_distrib</code>: A function or distribution constructor that creates the likelihood distribution for observed data points.</li><li><code>st_model</code>: A stateful Lux model that can be called with parameters to generate predictions.</li></ul><p><strong>Returns</strong></p><p>A function <code>(xs, ys) -&gt; Turing.Model</code> that creates a Turing model when given input data <code>xs</code> and observed data <code>ys</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vboussange/HybridDynamicModels.jl/blob/e9e680a3e24f31977a06b803d8bdf93eabaf3d3d/src/train.jl#L73-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridDynamicModels.MCSamplingBackend" href="#HybridDynamicModels.MCSamplingBackend"><code>HybridDynamicModels.MCSamplingBackend</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MCSamplingBackend(sampler, n_iterations, datadistrib; kwargs...)</code></pre><p>Training backend for Bayesian inference using Monte Carlo sampling. !!! warning <code>Conditional loading</code>   You need to load <code>Turing</code>, <code>ComponentArrays</code> and <code>Lux</code> before loading <code>HybridDynamicModels</code> to use <a href="#HybridDynamicModels.MCSamplingBackend">MCSamplingBackend</a>.</p><p><strong>Arguments</strong></p><ul><li><code>sampler</code>: Turing.jl MCMC sampler.</li><li><code>n_iterations</code>: Number of MCMC samples.</li><li><code>datadistrib</code>: Data distribution for likelihood.</li><li><code>kwargs</code>: Additional sampler options.</li></ul><p><strong>Inputs</strong></p><ul><li><code>sampler</code>: MCMC sampling algorithm.</li><li><code>n_iterations</code>: Total posterior samples.</li><li><code>datadistrib</code>: Distribution for data likelihood.</li></ul><p><strong>Outputs</strong></p><ul><li>NamedTuple with MCMC chains and model state.</li></ul><p><strong>Behavior</strong></p><p>Performs Bayesian inference using MCMC sampling on models with priors.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; backend = MCSamplingBackend(NUTS(0.65), 1000, LogNormal)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vboussange/HybridDynamicModels.jl/blob/e9e680a3e24f31977a06b803d8bdf93eabaf3d3d/src/train.jl#L41-L70">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/customtraining_example/">« Overloading the <code>train</code> function</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 23 September 2025 07:24">Tuesday 23 September 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
