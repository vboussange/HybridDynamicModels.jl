# Data Loading with [`SegmentedTimeSeries`](@ref)

This tutorial demonstrates the [`SegmentedTimeSeries`](@ref) data loader for batching and segmentation of time series data.

```julia; echo = false; results = "hidden"
using HybridDynamicModels
using Plots
using Random
using Statistics

function plot_segmentation(dataloader)
    plt = plot()

    tokenized = tokenize(dataloader)

    for token in tokens(tokenized)
        if token > 6
            break
        end
        segment_data, segment_times = tokenized[token]
        plot!(plt, segment_times, fill(token, length(segment_times)),
              linewidth = 2,
              color = token % 2,
              label = "")
    end
    xlabel!(plt, "Time")
    ylabel!(plt, "Segment index")

    return plt
end
```

## Basic Usage

Create synthetic time series data for demonstration:

```julia
tsteps = 0.0:0.1:20.0
data = randn(2, length(tsteps))
```

Create a `SegmentedTimeSeries` dataloader:

```julia
segment_length = 20

dataloader = SegmentedTimeSeries((data, tsteps);
                                segment_length)
```

Key parameters:
- `segment_length`: Number of time points per segment
- `shift`: Step size between segments (default: `segment_length`)
- `batchsize`: Number of segments per batch

The dataloader accepts tuples of arrays where the last dimension represents time:

```julia
other_data = randn(size(data))
shift = 10
dataloader = SegmentedTimeSeries((data, other_data, tsteps);
                                segment_length,
                                shift,
                                batchsize = 2)

for (i, (segment_data, segment_other_data, segment_times)) in enumerate(dataloader)
    i > 3 && break
    println("Segment $i: time range $(segment_times[1]) to $(segment_times[end])")
end
```


## Segmentation Strategies

The following visualization shows how `segment_length` and `shift` parameters affect data segmentation:

```julia; echo = false
segment_lengths = [10, 30]
shifts = [15, 5]

plots = []

for (i, seg_len) in enumerate(segment_lengths)
    for (j, shift_val) in enumerate(shifts)
        dataloader = SegmentedTimeSeries((data, tsteps);
                                        segment_length = seg_len,
                                        shift = shift_val)
        p = plot_segmentation(dataloader)
        plot!(p, title = "segment_length=$seg_len, shift=$shift_val",
              size = (250, 200), titlefontsize = 10)
        j > 1 && plot!(p, ylabel = "")
        i < 2 && plot!(p, xlabel = "")
        push!(plots, p)
    end
end

plot(plots..., layout = (2, 2), size = (600, 400))
```

Smaller `shift` values create more overlap between segments, while larger `segment_length` values capture longer temporal dependencies.

## Tokenization

Tokenization enables indexed access to individual segments, useful for associating segments with specific initial conditions or metadata:

```julia
tokenized_dataloader = tokenize(dataloader)

# Get available tokens
tokens_list = collect(tokens(tokenized_dataloader))

# Access specific segment
token = tokens_list[1]
segment_data, segment_times = tokenized_dataloader[token]
```

## Shuffling and Partial Segments

By default, segments are processed in deterministic order:

```julia
for (i, (tok, _)) in enumerate(tokenize(dataloader))
    i > 5 && break
    println("Batch $i contains tokens: ", tok)
end
```

Enable shuffling for randomized training:

```julia
rng = Random.MersenneTwister(42)
dataloader_shuffled = SegmentedTimeSeries((data, tsteps);
                                         segment_length,
                                         shift,
                                         shuffle = true,
                                         rng = rng)

for (i, (tok, _)) in enumerate(tokenize(dataloader_shuffled))
    i > 5 && break
    println("Batch $i contains tokens: ", tok)
end
```

Additional options include `partial_segment` and `partial_batch` parameters for handling incomplete segments and batches.